# 字典區域（Wiki or 百度）
**指令集架構（英語：Instruction Set Architecture，縮寫為ISA）**
>又稱指令集或指令集體系，是電腦架構中與程式設計有關的部分，包含了基本資料類型，指令集，暫存器，尋址模式，儲存體系，中斷，異常處理以及外部I/O。指令集架構包含一系列的opcode即操作碼（機器語言），以及由特定處理器執行的基本命令。
>
**現場可程式化邏輯閘陣列（英語：Field Programmable Gate Array，縮寫為FPGA）**
>以PAL、GAL、CPLD等可编程逻辑器件为技术基础发展而成。作为特殊应用集成电路中的一种半定制电路，它既弥补全定制电路不足，又克服原有可编程逻辑控制器逻辑门数有限的缺点。
>
**特殊应用集成电路（英语：Application Specific Integrated Circuit，缩写：ASIC）**
>指依产品需求不同而全定制的特殊规格集成电路，是一种有别于标准工业IC（例如7400系列或4000系列[1] ）的集成电路产品。例如，设计用来执行数字录音机或是高效能的比特币挖矿机功能的IC就是ASIC。ASIC芯片通常使用金氧半导体场效应管(MOSFET)技术的半导体工艺。
>
**ARM架構，過去稱作進階精簡指令集機器（英語：Advanced RISC Machine，更早稱作艾康精簡指令集機器，Acorn RISC Machine）**
>是一個精簡指令集（RISC）處理器架構家族，其廣泛地使用在許多嵌入式系統設計。由於節能的特點，其在其他領域上也有很多作為。ARM處理器非常適用於行動通訊領域，符合其主要設計目標為低成本、高效能、低耗電的特性。另一方面，超級電腦消耗大量電能，ARM同樣被視作更高效的選擇[3]。安謀控股（ARM Holdings）開發此架構並授權其他公司使用，以供他們實現ARM的某一個架構，開發自主的系統單晶片和系統模組（system-on-module，SoC）。
>
**立即數**
>指在立即尋址方式指令中給出的數。可以是8位、16位或32位，該數值緊跟在操作碼之後。如果立即數為16位或32位，那麼，它將按“高高低低”的原則進行存儲。
>
**伪指令**
>不是真正的指令，也就是不是最终的指令，是用于指示汇编程序如何汇编源程序，所以这种语句又叫命令语句，例如伪指令告诉汇编程序，该源程序如何分段，有哪些逻辑段在程序段中，哪些是当前段等等，伪指令语句的这些命令功能是由汇编程序在汇编源程序时，通过执行另外一段程序来完成的，而不是在运行目标程序时实现的。
>
# 前導
製作團隊一開始預期RISC-V（此V為羅馬數字的5）為：
* 能夠參與所有領域的開發（小至嵌入式系統大至計算機的處理器）
* 兼容性強，容納各種程式開發語言
* 能不因爲時代而落後而無法使用
* 能夠對微體系結構樣式都有效
* 成爲新一代的加速器的基礎
## 隨閲讀順序進展
* 模塊化導致其不容易改變，不容易爆棚，難以學習
* ISA設計基本框框
  * 成本
  * 簡潔性
  * 性能
  * 架構和具體實現的分離
  * 提升空間
  * 程序大小
  * 易於編程、編譯、鏈接（列如兒童積木）<br>
`此七項來自原文`

### 簡單概述一下 
* 成本為晶粒大小
* 簡潔性為簡單的ISA
* 性能為處理速度
* 架構和具體實現的分離為分流處理減少壓力
* 提升空間為字節壓減
* 程序大小就程序大小
* 易於編程、編譯、鏈接<br>
`ARM-32，MIPS-32 和 x86-32
这是一个可选部分，如果对某个主题感兴趣的话，读者可以深入研究它们，但它们对于理解
本书的其余部分并不必要。例如，我们对于 ISA 的称呼不是官方名称。32 位地址 ARM ISA
有许多版本，第一个诞生于 1986 年，最新版本在 2005 年出现，称为 ARMv7。ARM-32 通
常是指 ARMv7 ISA。MIPS 也有许多 32 位版本，但我们指的是原版，称为 MIPS I（“MIPS32” 
是一个更新的，不同于我们称之为 MIPS-32 的 ISA）。英特尔的第一个 16 位地址架构是 1978
年的 8086，其中 80386 ISA 在 1985 年扩展到 32 位地址。我们的 x86-32 表示法通常是指 IA32，它的 x86 ISA 的 32 位地址版本。鉴于这些 ISA 的数不清的变体的存在，我们发现我们
的非标准术语反而最不容易混淆。`
### RV321 :RISC-V基礎整數指令集
#### 6大基本指令（32位長）：
* R型指令：寄存器
* I型指令：短立即數和訪存load操作
* S型指令：訪存store
* B型指令：條件跳轉
* U型指令：長立即數
* J型指令：無條件跳轉<br>

### 第二章 
清楚地講解了其指令格式的開發觀念，並介紹了他們的空間利用效率，從而減少了複雜性（亂序、算術指令的移位、分支的有效處理），還不斷一直説明了它們吸取前人的弊端而進而優化，不犯下前人的失誤。重點描述了它們x0寄存器的優點，以及它們的子集獨立就擁有的完整性，可讓程序員自行選擇，不被綁死。
第三章
### 第三章
![image](https://user-images.githubusercontent.com/99935979/210744670-2efb8d2d-8050-4aea-b006-f8223a039bcf.png)<br>
`圖源自於RISC-V手冊:此圖表示其寄存器的轉換用法與保留`<br>
主要講解了變量應該盡量存放在寄存器中，同時也要頻發地保存和恢復寄存器，因爲它們同樣會訪問内存，并且展示了它們擁有足夠多的寄存器的優點。
寄存器大致可分爲兩種：
* 臨時寄存器
* 保存寄存器
### 滙編器
大多數的RISC—V指令依賴於其x0的寄存器，將跳轉，返回，等於0時轉移等等作爲僞指令。
![image](https://user-images.githubusercontent.com/99935979/210859985-9d40eddf-8ff9-475d-99f9-97e05ab851c2.png)
匯編程序的開頭為匯編指示符（命令作用）
指示符例子：
* .text：进入代码段。
* .align 2：后续代码按 22 字节对齐
* .globl main：声明全局符号“main”
靜態鏈接和動態鏈接的問題與執行方式，與存根函數的利用
加載器就是所謂的前置作業作用的存在
### 第四章
RV32M =>整數乘法，除法指令
除法：也具有有符號和無符號之分：rem、remu能在目標寄存器中寫入餘數
乘法：因爲積的長度是乘數和被乘數的長度和（32+32=64），同時又擁有有無符號之差，所以RISC-V中有四個乘法指令：
* mul（64位中低32位）
* mulh（有符高32位）
* mulhu（unsigned）（無符高32位）
* mulhsu（兩著皆要高32位）
### 第五章
`RISC-V服從IEEE 754-2008浮點標準`<br>
浮點寄存器=>RV32F、RV32D<br>
使用獨立的f寄存器<br>
兩組寄存器同時使用后處理器能在不增加指令格式中寄存器描述符所占空間的情況下使用兩組寄存器來將寄存器容量和帶寬翻倍（處理器性能up）<br>
爲了交換各獨立寄存器之間的訊息需要加載和存儲<br>
加載指令：flw，fld<br>
存儲指令：fsw，fsd<br>
皆和lw和sw擁有同樣的尋址模式和指令格式，列入算數運算指令有fadd.s,fsub.d,fmul.s等等進行分明<br>
除此之外，因爲大多數浮點算法在執行方式為：乘法指令=>加減法指令。因此RISC-V為程序員提供了融合指令，這讓計算機節省一些不必要浪費的資源。（一次吃完跟分兩段時間吃的差別）
這些指令需要一條新指令格式指定第4個寄存器（R4；R格式變種）<br>
RV32F/D 沒有浮點分支指令，取而代之為浮點比較指令。（設0、1進行判斷式跳轉）<br>
RV32F/D支持32位有符號整數、32位無符號整數、32位浮點和64位之間浮點進行所有組合的轉換，RV32F也提供了將數據從f寄存器移動到x寄存器的指令（fmv.x.w）以及反方向移動數據指令（fmv.w.x）.<br>
符號注入指令：<br>
1.浮點號註冊（fsgnj.s，fsgnj.d）：結果的號位是rs2的號位。<br>
2.浮點號取反注入（fsgnjn.s，fsgnjn.d）：結果的號位與rs2的號位相對應。<br>
3.浮點號異或註冊（fsgnjx.s，fsgnjx.d）：結果號位是rs1和rs2的號位異或的
結果。<br>
### 第六章
RV32A分爲兩分種類型的原子操作：<br>
* 内存原子操作（AMO）<br>
* 加載保留/條件存儲（load reserved / store conditional）<br>

解釋了兩條指令之間操作的原子性。（唯我獨尊境界，不易受外界干擾）<br>
編程語言的開發者會假體系統提供了原始的比較-交換（compare-and-swap）操作：比較一個寄存器中的值和另一個寄存器中的地址指向的值，如果它們相同，將第三個寄存
存器中的值和內部存器中的值進行交換。這是一條通用的同步原語，其他的同步操作可以以它為基礎來完成。
RV32A是可選添加套件，簡單有簡單的好，複雜有複雜的强大。
### 第七章
舊式的壓縮方式形成的ISA為處理器和編譯器帶來了不好的影響，也對程序員不友善：減小立即數域，操作數改變<br>
RV32C：每條短指令必須和一條標準的32位RISC-V指令對標。<br>
16位指令對滙編器和連接器特化，能否以短指令取代對應的寬指令有它們決定。<br>
壓縮至16位的三要觀點：<br>
* 對十個常用寄存器（a0-a5，s0-s1，sp及ra）訪問的頻率遠遠超過其他寄存器
* 許多指令的寫入目標是它的源操作數之一
* 立即數趨於很小，而且還有一些指令比較喜歡某些特定的立即數。
RV32C有它的缺陷（特殊機制）但運用得當將可以有效地進行壓縮。<br>
### 第八章
數據并行：大量數據可供應用程序同時計算<br>
著名的數據級并行架構：單指令多數據(SIMD，Single Instruction Multiple Data)。<br>
向量計算器從內存中收集數據並將它們放長的，順序的向量寄存器中。在這些向量寄存器上，流水線執行單位可以高效地執行運算。然後，向量存器將結果從向量存器中取出，並將其並分散存儲回主存儲。<br>
向量指令各自都擁有幾個類型，取決於源操作數是否都是向量（.vv） or 源操作數包含一個向量和一個標量（.vs）。<br>
向量ISA爲了保持元素數量的靈活性，向量處理器會計算最大向量長度（mvl），受容器限制，向量程序使用向量寄存器可以運算的最大向量長度。<br>
RV32V：將數據類型和長度與向量寄存器而不是與指令操作密碼相關聯。程序在執行向數量計算指令之前使用它們的數據類型和廣度標記向數量寄存器。<br>
這裏也介紹了動態類型的好處，列入可以禁用未使用的向量寄存器。此功能可以將所有的向量存儲器分配給已啓用的向量寄存器。<br>
向量寄存器類型設定指令為vsetdcfg<br>
向量的LOAD 和 STORE 最簡單情況為處理按順序存儲的一維數組。<br>
loadstore指令有兩類<br>
訪問順序，可以提供更高的内存帶寬經且,對於常看到的步驟長訪問，使用vld和vst可以縮小代碼長度，並減少執行的指令數：<br>
* vld<br>
* vst<br>

需要兩個源寄存器：起始地址 and 以字節為單位的步長：<br>
* vlds<br>
* vsts<br>

向量處理器一次操作一個向量元素，但由於元素操作根據定義上市獨立的，理論上處理器可以同時計算所有向量元素。<br>
RV32G最大位為64位，而向量處理器在每個時鐘周期内操作兩、四、或八個64位元素。<br>
RV32V的模塊化向量所帶的優勢體現了RISC-V的重要性，我們可以從書中的數據比較來得出此番結論。<br>
### 第九章<br>
主要介紹了RV32G指令集（32位），RV64V(64位)的關聯。<br>
RV64I添加字版本的加法和減法指令：addw、addiw、subw<br>
RV64I添加字版本的移位指令：sllw、slliw、srlw、srliw、sraw、sraiw<br>
RV64加載和存儲雙字指令：ld，sd<br>
RV64F和RV64D添加了整數雙字轉換指令（長整數）。<br>
RV64D浮點指令：fmv.x.w、fmv.w.x<br>
RV64<=>RV32:超集關係（基本）<br>
`列外`壓縮指令=>RV64C放棄了壓縮跳轉並鏈接（c.jal）和整數和浮點加載和存儲字指令（c.lw、c.sw、c.lwsp等等）<br>
RV64C也添加了字加減指令（c.addw、c.addiw、c.subw）以及加載和存儲雙字指令（c.ld、c.sd、c.ldsp、c.sdsp）<br>


 
大多就在說儲存上的差異，使用插入的可以使程式碼變短。<br>
### 第十章<br>
在說錯誤以及後續的處理，<br>
### 第十一章<br>
則是在說未來的發展性<br>


