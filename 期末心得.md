# 字典區域（Wiki or 百度）
**指令集架構（英語：Instruction Set Architecture，縮寫為ISA）**
>又稱指令集或指令集體系，是電腦架構中與程式設計有關的部分，包含了基本資料類型，指令集，暫存器，尋址模式，儲存體系，中斷，異常處理以及外部I/O。指令集架構包含一系列的opcode即操作碼（機器語言），以及由特定處理器執行的基本命令。
>
**現場可程式化邏輯閘陣列（英語：Field Programmable Gate Array，縮寫為FPGA）**
>以PAL、GAL、CPLD等可编程逻辑器件为技术基础发展而成。作为特殊应用集成电路中的一种半定制电路，它既弥补全定制电路不足，又克服原有可编程逻辑控制器逻辑门数有限的缺点。
>
**特殊应用集成电路（英语：Application Specific Integrated Circuit，缩写：ASIC）**
>指依产品需求不同而全定制的特殊规格集成电路，是一种有别于标准工业IC（例如7400系列或4000系列[1] ）的集成电路产品。例如，设计用来执行数字录音机或是高效能的比特币挖矿机功能的IC就是ASIC。ASIC芯片通常使用金氧半导体场效应管(MOSFET)技术的半导体工艺。
>
**ARM架構，過去稱作進階精簡指令集機器（英語：Advanced RISC Machine，更早稱作艾康精簡指令集機器，Acorn RISC Machine）**
>是一個精簡指令集（RISC）處理器架構家族，其廣泛地使用在許多嵌入式系統設計。由於節能的特點，其在其他領域上也有很多作為。ARM處理器非常適用於行動通訊領域，符合其主要設計目標為低成本、高效能、低耗電的特性。另一方面，超級電腦消耗大量電能，ARM同樣被視作更高效的選擇[3]。安謀控股（ARM Holdings）開發此架構並授權其他公司使用，以供他們實現ARM的某一個架構，開發自主的系統單晶片和系統模組（system-on-module，SoC）。
>
**立即數**
>指在立即尋址方式指令中給出的數。可以是8位、16位或32位，該數值緊跟在操作碼之後。如果立即數為16位或32位，那麼，它將按“高高低低”的原則進行存儲。
>
**伪指令**
>不是真正的指令，也就是不是最终的指令，是用于指示汇编程序如何汇编源程序，所以这种语句又叫命令语句，例如伪指令告诉汇编程序，该源程序如何分段，有哪些逻辑段在程序段中，哪些是当前段等等，伪指令语句的这些命令功能是由汇编程序在汇编源程序时，通过执行另外一段程序来完成的，而不是在运行目标程序时实现的。
>
# 前導
製作團隊一開始預期RISC-V（此V為羅馬數字的5）為：
* 能夠參與所有領域的開發（小至嵌入式系統大至計算機的處理器）
* 兼容性強，容納各種程式開發語言
* 能不因爲時代而落後而無法使用
* 能夠對微體系結構樣式都有效
* 成爲新一代的加速器的基礎
## 隨閲讀順序進展
* 模塊化導致其不容易改變，不容易爆棚，難以學習
* ISA設計基本框框
  * 成本
  * 簡潔性
  * 性能
  * 架構和具體實現的分離
  * 提升空間
  * 程序大小
  * 易於編程、編譯、鏈接（列如兒童積木）<br>
`此七項來自原文`

### 簡單概述一下 
* 成本為晶粒大小
* 簡潔性為簡單的ISA
* 性能為處理速度
* 架構和具體實現的分離為分流處理減少壓力
* 提升空間為字節壓減
* 程序大小就程序大小
* 易於編程、編譯、鏈接<br>
`ARM-32，MIPS-32 和 x86-32
这是一个可选部分，如果对某个主题感兴趣的话，读者可以深入研究它们，但它们对于理解
本书的其余部分并不必要。例如，我们对于 ISA 的称呼不是官方名称。32 位地址 ARM ISA
有许多版本，第一个诞生于 1986 年，最新版本在 2005 年出现，称为 ARMv7。ARM-32 通
常是指 ARMv7 ISA。MIPS 也有许多 32 位版本，但我们指的是原版，称为 MIPS I（“MIPS32” 
是一个更新的，不同于我们称之为 MIPS-32 的 ISA）。英特尔的第一个 16 位地址架构是 1978
年的 8086，其中 80386 ISA 在 1985 年扩展到 32 位地址。我们的 x86-32 表示法通常是指 IA32，它的 x86 ISA 的 32 位地址版本。鉴于这些 ISA 的数不清的变体的存在，我们发现我们
的非标准术语反而最不容易混淆。`
### RV321 :RISC-V基礎整數指令集
#### 6大基本指令（32位長）：
* R型指令：寄存器
* I型指令：短立即數和訪存load操作
* S型指令：訪存store
* B型指令：條件跳轉
* U型指令：長立即數
* J型指令：無條件跳轉<br>

### 第二章 
清楚地講解了其指令格式的開發觀念，並介紹了他們的空間利用效率，從而減少了複雜性（亂序、算術指令的移位、分支的有效處理），還不斷一直説明了它們吸取前人的弊端而進而優化，不犯下前人的失誤。重點描述了它們x0寄存器的優點，以及它們的子集獨立就擁有的完整性，可讓程序員自行選擇，不被綁死。
第三章
### 第三章
![image](https://user-images.githubusercontent.com/99935979/210744670-2efb8d2d-8050-4aea-b006-f8223a039bcf.png)<br>
`圖源自於RISC-V手冊:此圖表示其寄存器的轉換用法與保留`<br>
主要講解了變量應該盡量存放在寄存器中，同時也要頻發地保存和恢復寄存器，因爲它們同樣會訪問内存，并且展示了它們擁有足夠多的寄存器的優點。
寄存器大致可分爲兩種：
* 臨時寄存器
* 保存寄存器
### 滙編器
大多數的RISC—V指令依賴於其x0的寄存器，將跳轉，返回，等於0時轉移等等作爲僞指令。
![image](https://user-images.githubusercontent.com/99935979/210859985-9d40eddf-8ff9-475d-99f9-97e05ab851c2.png)
匯編程序的開頭為匯編指示符（命令作用）
指示符例子：
* .text：进入代码段。
* .align 2：后续代码按 22 字节对齐
* .globl main：声明全局符号“main”
靜態鏈接和動態鏈接的問題與執行方式，與存根函數的利用
加載器就是所謂的前置作業作用的存在
### 第四章
RV32M =>整數乘法，除法指令
除法：也具有有符號和無符號之分：rem、remu能在目標寄存器中寫入餘數
乘法：因爲積的長度是乘數和被乘數的長度和（32+32=64），同時又擁有有無符號之差，所以RISC-V中有四個乘法指令：
* mul（64位中低32位）
* mulh（有符高32位）
* mulhu（unsigned）（無符高32位）
* mulhsu（兩著皆要高32位）
### 第五章
`RISC-V服從IEEE 754-2008浮點標準`<br>
浮點寄存器=>RV32F、RV32D<br>
使用獨立的f寄存器<br>
兩組寄存器同時使用后處理器能在不增加指令格式中寄存器描述符所占空間的情況下使用兩組寄存器來將寄存器容量和帶寬翻倍（處理器性能up）<br>
爲了交換各獨立寄存器之間的訊息需要加載和存儲<br>
加載指令：flw，fld<br>
存儲指令：fsw，fsd<br>
皆和lw和sw擁有同樣的尋址模式和指令格式，列入算數運算指令有fadd.s,fsub.d,fmul.s等等進行分明<br>
除此之外，因爲大多數浮點算法在執行方式為：乘法指令=>加減法指令。因此RISC-V為程序員提供了融合指令，這讓計算機節省一些不必要浪費的資源。（一次吃完跟分兩段時間吃的差別）
這些指令需要一條新指令格式指定第4個寄存器（R4；R格式變種）<br>
RV32F/D 沒有浮點分支指令，取而代之為浮點比較指令。（設0、1進行判斷式跳轉）<br>
RV32F/D支持32位有符號整數、32位無符號整數、32位浮點和64位之間浮點進行所有組合的轉換，RV32F也提供了將數據從f寄存器移動到x寄存器的指令（fmv.x.w）以及反方向移動數據指令（fmv.w.x）.<br>
符號注入指令：<br>
1.浮點號註冊（fsgnj.s，fsgnj.d）：結果的號位是rs2的號位。<br>
2.浮點號取反注入（fsgnjn.s，fsgnjn.d）：結果的號位與rs2的號位相對應。<br>
3.浮點號異或註冊（fsgnjx.s，fsgnjx.d）：結果號位是rs1和rs2的號位異或的
結果。<br>
### 第六章
RV32A分爲兩分種類型的原子操作：<br>
* 内存原子操作（AMO）<br>
* 加載保留/條件存儲（load reserved / store conditional）<br>
解釋了兩條指令之間操作的原子性。<br>
編程語言的開發者會假體系統提供了原始的比較-交換（compare-and-swap）操作：比較一個寄存器中的值和另一個寄存器中的地址指向的值，如果它們相同，將第三個寄存
存器中的值和內部存器中的值進行交換。這是一條通用的同步原語，其他的同步操作可以以它為基礎來完成。
RV32A是可選添加套件，簡單有簡單的好，複雜有複雜的强大。





